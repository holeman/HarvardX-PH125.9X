---
title: "MovieLens Project HarvardX PH125.9X"
author: "Herbert Holeman"
date: "12/1/2021"
output: pdf_document
---


# SUMMARY

The movie provider Netflix Inc. uses a computerized recommendation system. It predicts user movie ratings based on a massive collection of user viewing data

To that end, this script generates a movie ratings predictor and calculates a root mean squared error (RMSE) for evaluating prediction performance. These are the results of this algorithm:

|method                                  |      RMSE|
|:---------------------------------------|---------:|
|Average movie rating model              | 1.0603313|
|Movie effect model                      | 0.9423475|
|Regularized movie and user effect model | 0.8648170|

# METHODS AND ANALYSIS

While the data from the Netflix system are not publicly available, the GroupLens Lab generated its own such database with over 20 million ratings for over 27,000 movies viewed by more than 138,000 users. The edx dataset, used in this project is a subset of the GroupLens database. It contains some 69,878 movies and 10,677 user ratings.

In developing this script's predictor, the caret (acronm for Classification And REgression Training) family of packages is used to perform the following tasks.

## SETUP

Load required R coding packages and download MovieLens 10M data. Run setup code to separate the data into the edx dataset, for training, and the validation dataset, for testing.

```{r setup, echo=FALSE}
if(!require(caret)) install.packages("caret")
if(!require(tidyverse)) install.packages("tidyverse")
if(!require(data.table)) install.packages("data.table")
if(!require(dplyr)) install.packages("dplyr")
if(!require(sqldf)) install.packages("sqldf")
if(!require(lubridate)) install.packages("lubridate")
if(!require(ggthemes)) install.packages("ggthemes")

library(tidyverse)
library(caret)
library(data.table)
library(dplyr)
library(sqldf)
library(lubridate)
library(ggthemes)

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")


movies <- as.tibble(movies) %>% mutate(movieId = as.numeric(movieId),
                                       title = as.character(title),
                                       genres = as.character(genres))

movielens <- left_join(ratings, movies, by = "movieId")

set.seed(1, sample.kind="Rounding") 
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)
```



## EXPLORE DATA

Probe the dataset to examine its structure and key prediction features: userId, movieId, and rating.


```{r data look-see}
str(edx)
summary(edx)
anyNA(edx)
edx%>% 
  summarize(n_users = n_distinct(userId),
            n_movies = n_distinct(movieId))
```
Create Chart 1 to show movie viewer preference based on the time the Netflix dataset was compiled. A five star rating scheme (1 to 5 stars) was then used for scoring user preference and movie popularity. Follow up the chart with a tabulation of viewer scores by rating given. 

```{r, Chart 1 }
edx %>% 
  ggplot() +
  geom_histogram(aes(x= rating), bins = 30, 
  fill = "yellow", color="blue")+
  scale_x_discrete(limits = c(seq(0.5,5,0.5))) +
  labs(title = "Chart 1 Ratings by Scoring Scheme",
  subtitle = "edx dataset", x = "Ratings" )+
  theme_classic()

table(edx$rating)
summary(edx$rating)

```

Add a date feature to the dataset to evaluate ratings trend over the project's timeframe.

```{r add date feature and chart 2}
edx <- mutate(edx, date = as_datetime(timestamp))
edx %>% mutate(date = round_date(date, unit = "week")) %>% 
  group_by(date) %>%
  summarize(rating = mean(rating)) %>% 
  ggplot(aes(date,  rating))  + 
  geom_point() +
  geom_smooth()+
  labs(title="Chart 2 Movie Ratings Trend", 
       subtitle = "edx dataset", x = "Year") +
  theme_classic()

```

Create charts 3 and 4 to depict a big picture perspective of the users who view the movies and of the movies themselves.

```{r Charts 3-4, echo=FALSE}
edx %>% group_by(userId) %>% summarize(n = n()) %>%
  ggplot()+
  geom_histogram(aes(n), bins = 30, 
                 fill = "yellow", color = "blue")+
  scale_x_log10() +
  labs(title = "Chart 3 Ratings by User Id", 
  subtitle = "edx dataset", x="UserId",y="Number")+
  theme_classic()


edx %>%
  count(movieId) %>%
  ggplot(aes(n)) +
  geom_histogram( bins=30, fill = "yellow", color = "blue") +
  scale_x_log10() +
  labs(title = "Chart 4 Ratings by movie Id", subtitle = "edx dataset", 
  x="MovieId", y = "Number")+
  theme_classic()     
```
# BUILD THE RECOMMENDATION SYSTEM 

Make a simple baseline prediction of RMSE. 

* Get edx dataset mean rating 

```{r basic model}
mu <- mean(edx$rating)
mu

naive_rmse <- RMSE(edx$rating, mu)
naive_rmse

rmse_results <- data.frame(method = "Average movie rating model", 
RMSE = naive_rmse)

print(rmse_results %>% knitr::kable())
```
Improve baseline RMSE through analysis of bias as an error influencing both movie and user ratings. Show such in Chart 5 as movie effect and in Chart 6 as user effect. 

```{r chart 5 movie effect}
movie_avgs <- edx %>%
  group_by(movieId) %>%
  summarize(b_i = mean(rating - mu))

# Chart 5 movie effect
movie_avgs  %>%  
  ggplot(aes(b_i)) +
  geom_histogram(bins = 10, fill="beige", color= "blue")+
  labs(title="Chart 5 Movie Effect", subtitle="edx dataset")+
  theme_classic()    

predicted_ratings <- mu +  edx %>%
  left_join(movie_avgs, by='movieId') %>%
  pull(b_i)

model_1_rmse <- RMSE(predicted_ratings, edx$rating) 

rmse_results <- bind_rows(rmse_results, 
                          tibble(method="Movie effect model",  
                                 RMSE = model_1_rmse ))
print(rmse_results %>% knitr::kable())
```
```{r chart 6 user effect}
edx %>%
  group_by(userId) %>% 
  summarize(b_u = mean(rating)) %>% 
  filter(n()>=100) %>% 
  ggplot(aes(b_u)) +
  geom_histogram(bins = 10, fill="beige", color= "blue")+
  labs(title="Chart 6 User Effect", subtitle="edx dataset")+
  theme_classic()  

user_avgs <- edx %>%             
  left_join(movie_avgs, by='movieId') %>%
  group_by(userId) %>%
  summarize(b_u = mean(rating - mu - b_i))

predicted_ratings <- edx %>%   
  left_join(movie_avgs, by='movieId') %>% 
  left_join(user_avgs, by='userId') %>%
  mutate(pred = mu + b_i + b_u) %>%
  pull(pred)

model_2_rmse <- RMSE(predicted_ratings, edx$rating)

mse_results <- bind_rows(rmse_results,
                         data.frame(method="Movie and user effect model",
                                    RMSE = model_2_rmse))

print(rmse_results %>% knitr::kable())

```
Use regularization to get RMSE, a single number for prediction which minimizes sum of squares while penalizing for large values. Plot rmses vs lambdas to select the optimal lambda

```{r lambdas}

lambdas <- seq(0, 10, 0.25)

rmses <- sapply(lambdas, function(l){
 
  mu <- mean(edx$rating)

  b_i <- edx %>%
    group_by(movieId) %>%
    summarize(b_i = sum(rating - mu)/(n()+l))
  
  b_u <- edx %>%
    left_join(b_i, by="movieId") %>%
    group_by(userId) %>%
    
  summarize(b_u = sum(rating - b_i - mu)/(n()+l))

  predicted_ratings <- validation %>%
    left_join(b_i, by = "movieId") %>%
    left_join(b_u, by = "userId") %>%
    mutate(pred = mu + b_i + b_u) %>%
    pull(pred)
  RMSE(predicted_ratings, validation$rating)
})

qplot(lambdas, rmses, col = I("blue"),
      main = "Chart 7 Lambda - RMSE")

lambda <- lambdas[which.min(rmses)]
lambda 

rmse_results <- bind_rows(rmse_results,
                          data.frame(method="Regularized movie and user effect model",
RMSE = min(rmses)))
```
# RESULTS

```{r Results }
rmse_results %>% knitr::kable()
```
# CONCLUSION

The caret packages proves  dependable for machine language modeling, which in this case, builds a basic recommendation system using two predictors, movies and users.


